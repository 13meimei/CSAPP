# 2 信息的表示和处理

![](bits.jpg)

### 整数运算和浮点运算会有不同的数学属性，因为他们处理数字表示有限性的方式不同-精确vs近似

### 十进制和十六进制直接的转换（Python）

[d2h.py](d2h.py), [h2d.py](h2d.py)

### C语言中char 1B,short 2B, int 4B, 长整数和指针长度等于机器的字长（这里8）,float=4B, double=8B
[type_len.c](type_len.c)

### 我们要让程序对不同数据类型的确切大小不敏感，这样有更好的移植性，比如32位系统把指针赋给int是OK的但是到了64位系统中会导致问题

### 使用强制类型转发来访问不同程序对象的字节表示,
[show-bytes.c](show-bytes.c)

```shell
✗ ./show-bytes  1234
 39 30 00 00
 00 e4 40 46
 2c 5b c9 5b ff 7f 00 00
````

### 文本数据比而进程具有更强的平台独立性，因为字符串的表示本身做了抽象，字符串总是从地址开始遇到0x00结束，与字节顺序和字大小规则无关

如，show_bytes("12345", 6) 得到结果31 32 33 34 35 00

### 练习题2.7 下面的输出结果是0x61-0x66, 没用00，因为strlen不计最后的null
```c
const char *s = "abcdef";
show_bytes((byte_pointer)s, strlen(s));
```

### 查看机器代码，二进制代码是不兼容的（hexdump sum.o）
[sum.c](sum.c)

在我的mac 64是：00001d0 55 48 89 e5 89 7d fc 89 75 f8 8b 75 fc 03 75 f8

### 位向量一个很有用的应用是用来表示有限集合，对应的那个bit=1表示对应的元素存在，有点Bloom filter的味道

### 习题2.10 对任何一个向量a, a^a = 0， 应用这一属性，有下面的swap程序。
[inplace_swap.c](inplace_swap.c) 没用使用中间变量，这种交换方式不会有性能上的优势，仅仅是智力游戏

```c
*y = *x ^ *y;
*x = *x ^ *y;
*y = *x ^ *y;
```

很容易理解：执行第2行的时候，*x = *x ^ *y = *x ^ (*x ^ *y) = *y; 异或满足交换律，此时x地址里面存储的是y里面的值，然后第3行：*y = *x ^ *y = *y ^ (*x ^ *y) = *x  如此而已

### 习题2.11 承上题，利用上面的swap函数实现对调一个数组的元素，源程序的问题是对中间元素自身异或自身得到0
[reverse_array.c](reverse_array.c)

### 位级运算的一个常见应用是实现掩码运算，掩码是一个位模式。使用类似~0得到全1的掩码，而非使用0XFFF-F, 考虑移植性

### 习题2.13 只有bis和bic实现位设置和清除，而不使用其他C语言运算，实现位级|和^运算

理清题意：bis(x,m)对m的为1的bit对x置1，对应地，bic对应的bit清0， 而不是操作第mbit

异或的性质：x ^ y = (x & ~y) | (y & ~x) , x中的bits不被y包含的（x & ~y）加上y中的bits不被x包含的。

[bis_bic.c](bis_bic.c)

### 几乎所有的编译器/机器都会对有符号书使用算术右移，Java中可以明确指定

[Shift.java](Shift.java)

### 注意在C中，加法比移位运算优先级高，所以要写成 (1 << 2) + 3, 所以不确定就加括号吧，少年

### 
























